import React, { useEffect } from "react";
import "./RecentGames.css";
import { Divider, Feed, Header, Icon, Pagination, PaginationProps, Transition } from "semantic-ui-react";
import { FeedEventProps } from "semantic-ui-react/dist/commonjs/views/Feed/FeedEvent";
import ReactTimeAgo from "react-time-ago";
import { TTDataPropsTypeCombined } from "../../containers/shared";
import { getPlayersMap } from "../QHDataLoader/QHDataLoader";
import { DbMatch } from "../../types/database/models";

export interface RecentGamesProps {
    focusedPlayerId?: string;
}

export type RecentGamesCombinedProps = RecentGamesProps & TTDataPropsTypeCombined;

function RecentGames(props: RecentGamesCombinedProps): JSX.Element {
    const PAGE_SIZE = 5;
    // Track this in state, as we may potentially filter the matches to only be focused ones.
    const [matches, setMatches] = React.useState<DbMatch[]>(props.matches);
    const [currentPage, setCurrentPage] = React.useState<number>(1);

    // Runs on mount.
    useEffect(() => {
        sortAndFilterMatches();
    }, []);

    // When the matches change, re-sort them.
    useEffect(() => {
        sortAndFilterMatches();
    }, [props.matches]);

    const sortAndFilterMatches = (): void => {
        let sortedAndFilteredMatches: DbMatch[] = props.matches;
        // Determine which matches will make up our Recent Games set on mount to save performance.
        // If we are focusing on a player, do the filter now.
        if (props.focusedPlayerId) {
            sortedAndFilteredMatches = sortedAndFilteredMatches.filter(
                (match) =>
                    match.winning_player_id === props.focusedPlayerId ||
                    match.losing_player_id === props.focusedPlayerId
            );
        }

        // Sort list from newest to oldest
        sortedAndFilteredMatches = sortedAndFilteredMatches.sort((matchA, matchB) => {
            return new Date(matchB.date).getTime() - new Date(matchA.date).getTime();
        });

        // Set this filtered and sorted match object in state, for later use.
        setMatches(sortedAndFilteredMatches);
    };

    const getMatchEvents = (): FeedEventProps[] => {
        if (matches.length === 0 || props.players.length === 0) {
            return [];
        }

        const events: FeedEventProps[] = [];
        const playersMap = getPlayersMap(props.players);

        // Use index access for pagination, with a max result size of PAGE_SIZE and offset generated by the current page
        // * page-size.
        // - 1 as `currentPage` starts at 1, but we actually start at 0 for our page offset calculations.
        const offset = (currentPage - 1) * PAGE_SIZE;
        const nextPageOffset = currentPage * PAGE_SIZE;

        for (let i = offset; i < nextPageOffset; i++) {
            if (i > matches.length - 1) {
                break;
            }

            const match = matches[i];

            const winningPlayer = playersMap.get(match.winning_player_id);
            const losingPlayer = playersMap.get(match.losing_player_id);

            if (!(winningPlayer && losingPlayer)) {
                break;
            }

            events.push({
                meta: (
                    <div className={"event-content"}>
                        {winningPlayer.name} ({match.winning_player_original_elo}
                        <span className={"elo-gain"}>
                            +{match.winner_new_elo - match.winning_player_original_elo}={match.winner_new_elo}
                        </span>
                        ) defeated {losingPlayer.name} ({match.losing_player_original_elo}
                        <span className={"elo-loss"}>
                            -{match.losing_player_original_elo - match.loser_new_elo}={match.loser_new_elo}
                        </span>
                        ) <ReactTimeAgo date={new Date(match.date)} />
                        ...
                        <Divider />
                    </div>
                ),
                date: <div className={"event-date"}>{new Date(match.date).toDateString()}</div>,
                content: (
                    <div className={"event-summary"}>
                        <Icon name={winningPlayer.icon} color={"green"} />
                        <span className={"game-winner"}>{winningPlayer.name} </span>
                        <span className={"game-winner"}>({match.winning_player_score})</span>
                        <Icon name={"chevron right"} color={"orange"} />
                        <Icon name={losingPlayer.icon} color={"red"} />
                        <span className={"game-loser"}>{losingPlayer.name} </span>
                        <span className={"game-loser"}>({match.losing_player_score})</span>
                        <span className={"happy-hour"}>
                            {match.happy_hour && (
                                <span>
                                    <Icon name={"smile"} />
                                    Happy hour!
                                </span>
                            )}
                        </span>
                    </div>
                ),
                icon: winningPlayer.icon,
            });
        }

        return events;
    };

    const getTotalPages = (): number => {
        return Math.max(Math.ceil(matches.length / PAGE_SIZE), 1);
    };

    const handlePageChange = (event: React.MouseEvent<HTMLAnchorElement>, data: PaginationProps): void => {
        setCurrentPage(data.activePage as number);
    };

    return (
        <div className="recent-games">
            <Header as={"h2"} icon>
                <Icon name="history" circular />
                <Header.Content>Recent games</Header.Content>
            </Header>
            <Transition visible={!props.loading}>
                <span>
                    <Feed className={"games-feed"} events={getMatchEvents()} />
                    {
                        /* Show pagination if number of pages is greater than 1 */
                        getTotalPages() > 1 && (
                            <Pagination
                                totalPages={getTotalPages()}
                                defaultActivePage={1}
                                onPageChange={handlePageChange}
                                siblingRange={0}
                                firstItem={null}
                                lastItem={null}
                            />
                        )
                    }
                </span>
            </Transition>
        </div>
    );
}

export default RecentGames;
